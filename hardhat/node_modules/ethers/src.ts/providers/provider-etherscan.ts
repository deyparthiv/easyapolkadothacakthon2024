/**
 *  [[link-etherscan]] provides a third-party service for connecting to
 *  various blockchains over a combination of JSON-RPC and custom API
 *  endpoints.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Holesky Testnet (``holesky``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Base (``base``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *
 *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]
 */

import { AbiCoder } from "../abi/index.js";
import { Contract } from "../contract/index.js";
import { accessListify, Transaction } from "../transaction/index.js";
import {
    defineProperties,
    hexlify, toQuantity,
    FetchRequest,
    assert, assertArgument, isError,
//    parseUnits,
    toUtf8String
 } from "../utils/index.js";

import { AbstractProvider } from "./abstract-provider.js";
import { Network } from "./network.js";
import { NetworkPlugin } from "./plugins-network.js";
import { showThrottleMessage } from "./community.js";

import { PerformActionRequest } from "./abstract-provider.js";
import type { Networkish } from "./network.js";
//import type { } from "./pagination";
import type { TransactionRequest } from "./provider.js";

const THROTTLE = 2000;

function isPromise<T = any>(value: any): value is Promise<T> {
    return (value && typeof(value.then) === "function");
}


/**
 *  When subscribing to the ``"debug"`` event on an Etherscan-based
 *  provider, the events receive a **DebugEventEtherscanProvider**
 *  payload.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
export type DebugEventEtherscanProvider = {
    action: "sendRequest",
    id: number,
    url: string,
    payload: Record<string, any>
} | {
    action: "receiveRequest",
    id: number,
    result: any
} | {
    action: "receiveError",
    id: number,
    error: any
};

const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";

/**
 *  A Network can include an **EtherscanPlugin** to provide
 *  a custom base URL.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
export class EtherscanPlugin extends NetworkPlugin {
    /**
     *  The Etherscan API base URL.
     */
    readonly baseUrl!: string;

    /**
     *  Creates a new **EtherscanProvider** which will use
     *  %%baseUrl%%.
     */
    constructor(baseUrl: string) {
        super(EtherscanPluginId);
        defineProperties<EtherscanPlugin>(this, { baseUrl });
    }

    clone(): EtherscanPlugin {
        return new EtherscanPlugin(this.baseUrl);
    }
}

const skipKeys = [ "enableCcipRead" ];

let nextId = 1;

/**
 *  The **EtherscanBaseProvider** is the super-class of
 *  [[EtherscanProvider]], which should generally be used instead.
 *
 *  Since the **EtherscanProvider** includes additional code for
 *  [[Contract]] access, in //rare cases// that contracts are not
 *  used, this class can reduce code size.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
export class EtherscanProvider extends AbstractProvider {

    /**
     *  The connected network.
     */
    readonly network!: Network;

    /**
     *  The API key or null if using the community provided bandwidth.
     */
    readonly apiKey!: null | string;

    readonly #plugin: null | EtherscanPlugin;

    /**
     *  Creates a new **EtherscanBaseProvider**.
     */
    constructor(_network?: Networkish, _apiKey?: string) {
        const apiKey = (_apiKey != null) ? _apiKey: null;

        super();

        const network = Network.from(_network);

        this.#plugin = network.getPlugin<EtherscanPlugin>(EtherscanPluginId);

        defineProperties<EtherscanProvider>(this, { apiKey, network });

        // Test that the network is supported by Etherscan
        this.getBaseUrl();
    }

    /**
     *  Returns the base URL.
     *
     *  If an [[EtherscanPlugin]] is configured on the
     *  [[EtherscanBaseProvider_network]], returns the plugin's
     *  baseUrl.
     */
    getBaseUrl(): string {
        if (this.#plugin) { return this.#plugin.baseUrl; }

        switch(this.network.name) {
            case "mainnet":
                return "https:/\/api.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            case "sepolia":
                return "https:/\/api-sepolia.etherscan.io";
            case "holesky":
                return "https:/\/api-holesky.etherscan.io";

            case "arbitrum":
                return "https:/\/api.arbiscan.io";
            case "arbitrum-goerli":
                return "https:/\/api-goerli.arbiscan.io";
           case "base":
                return "https:/\/api.basescan.org";
            case "base-sepolia":
                return "https:/\/api-sepolia.basescan.org";
            case "bnb":
                return "https:/\/api.bscscan.com";
            case "bnbt":
                return "https:/\/api-testnet.bscscan.com";
            case "matic":
                return "https:/\/api.polygonscan.com";
            case "matic-amoy":
                return "https:/\/api-amoy.polygonscan.com";
            case "matic-mumbai":
                return "https:/\/api-testnet.polygonscan.com";
            case "optimism":
                return "https:/\/api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https:/\/api-goerli-optimistic.etherscan.io";

            default:
        }

        assertArgument(false, "unsupported network", "network", this.network);
    }

    /**
     *  Returns the URL for the %%module%% and %%params%%.
     */
    getUrl(module: string, params: Record<string, string>): string {
        const query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
                accum += `&${ key }=${ value }`
            }
            return accum
        }, "");
        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: "");
        return `${ this.getBaseUrl() }/api?module=${ module }${ query }${ apiKey }`;
    }

    /**
     *  Returns the URL for using POST requests.
     */
    getPostUrl(): string {
        return `${ this.getBaseUrl() }/api`;
    }

    /**
     *  Returns the parameters for using POST requests.
     */
    getPostData(module: string, params: Record<string, any>): Record<string, any> {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }

    async detectNetwork(): Promise<Network> {
        return this.network;
    }

    /**
     *  Resolves to the result of calling %%module%% with %%params%%.
     *
     *  If %%post%%, the request is made as a POST request.
     */
    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {
        const id = nextId++;

        const url = (post ? this.getPostUrl(): this.getUrl(module, params));
        const payload = (post ? this.getPostData(module, params): null);

        this.emit("debug", { action: "sendRequest", id, url, payload: payload });

        const request = new FetchRequest(url);
        request.setThrottleParams({ slotInterval: 1000 });
        request.retryFunc = (req, resp, attempt: number) => {
            if (this.isCommunityResource()) {
                showThrottleMessage("Etherscan");
            }
            return Promise.resolve(true);
        };
        request.processFunc = async (request, response) => {
            const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)): { };
            const throttle = ((typeof(result.result) === "string") ? result.result: "").toLowerCase().indexOf("rate limit") >= 0;
            if (module === "proxy") {
                // This JSON response indicates we are being throttled
                if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                    this.emit("debug", { action: "receiveError", id, reason: "proxy-NOTOK", error: result });
                    response.throwThrottleError(result.result, THROTTLE);
                }
            } else {
                if (throttle) {
                    this.emit("debug", { action: "receiveError", id, reason: "null result", error: result.result });
                    response.throwThrottleError(result.result, THROTTLE);
                }
            }
            return response;
        };

        if (payload) {
            request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            request.body = Object.keys(payload).map((k) => `${ k }=${ payload[k] }`).join("&");
        }

        const response = await request.send();
        try {
            response.assertOk();
        } catch (error) {
            this.emit("debug", { action: "receiveError", id, error, reason: "assertOk" });
            assert(false, "response error", "SERVER_ERROR", { request, response });
        }

        if (!response.hasBody()) {
            this.emit("debug", { action: "receiveError", id, error: "missing body", reason: "null body" });
            assert(false, "missing response", "SERVER_ERROR", { request, response });
        }

        const result = JSON.parse(toUtf8String(response.body));
        if (module === "proxy") {
            if (result.jsonrpc != "2.0") {
                this.emit("debug", { action: "receiveError", id, result, reason: "invalid JSON-RPC" });
                assert(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
            }

            if (result.error) {
                this.emit("debug", { action: "receiveError", id, result, reason: "JSON-RPC error" });
                assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }

            this.emit("debug", { action: "receiveRequest", id, result });

            return result.result;

        } else {
            // getLogs, getHistory have weird success responses
            if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
                this.emit("debug", { action: "receiveRequest", id, result });
                return result.result;
            }

            if (result.status != 1 || (typeof(result.message) === "string" && !result.message.match(/^OK/))) {
                this.emit("debug", { action: "receiveError", id, result });
                assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }

            this.emit("debug", { action: "receiveRequest", id, result });

            return result.result;
        }
    }

    /**
     *  Returns %%transaction%% normalized for the Etherscan API.
     */
    _getTransactionPostData(transaction: TransactionRequest): Record<string, string> {
        const result: Record<string, string> = { };
        for (let key in transaction) {
            if (skipKeys.indexOf(key) >= 0) { continue; }

            if ((<any>transaction)[key] == null) { continue; }
            let value = (<any>transaction)[key];
            if (key === "type" && value === 0) { continue; }
            if (key === "blockTag" && value === "latest") { continue; }

            // Quantity-types require no leading zero, unless 0
            if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {
                value = toQuantity(value);

            } else if (key === "accessList") {
                value = "[" + accessListify(value).map((set) => {
                    return `{address:"${ set.address }",storageKeys:["${ set.storageKeys.join('","') }"]}`;
                }).join(",") + "]";

            } else if (key === "blobVersionedHashes") {
                if (value.length === 0) { continue; }

                // @TODO: upd